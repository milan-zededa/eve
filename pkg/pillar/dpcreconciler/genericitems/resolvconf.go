// Copyright (c) 2022 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

package genericitems

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"reflect"

	"github.com/lf-edge/eve-libs/depgraph"
	"github.com/lf-edge/eve/pkg/pillar/base"
)

const (
	// resolvConfFilename : path to resolv.conf managed by NIM.
	resolvConfFilename = "/etc/resolv.conf"
)

// ResolvConf : a singleton item representing resolv.conf.
type ResolvConf struct {
	DNSServers map[string][]net.IP // interface name -> DNS servers
}

// Name returns the full path of the resolv.conf file.
func (r ResolvConf) Name() string {
	return resolvConfFilename
}

// Label is not defined.
func (r ResolvConf) Label() string {
	return ""
}

// Type of the item.
func (r ResolvConf) Type() string {
	return ResolvConfTypename
}

// Equal is currently lazily based on DeepEqual.
func (r ResolvConf) Equal(other depgraph.Item) bool {
	r2, isResolvConf := other.(ResolvConf)
	if !isResolvConf {
		return false
	}
	return reflect.DeepEqual(r.DNSServers, r2.DNSServers)
}

// External returns false.
func (r ResolvConf) External() bool {
	return false
}

// String prints all DNS entries of the resolv.conf.
func (r ResolvConf) String() string {
	if len(r.DNSServers) == 0 {
		return "resolv.conf with empty content"
	}
	str := "resolv.conf with DNS entries:"
	for ifName, dnsServers := range r.DNSServers {
		str += fmt.Sprintf("\n  *  %s: %v", ifName, dnsServers)
	}
	return str
}

// Dependencies returns nothing.
func (r ResolvConf) Dependencies() (deps []depgraph.Dependency) {
	return nil
}

// ResolvConfConfigurator implements Configurator interface (libs/reconciler) for resolv.conf.
type ResolvConfConfigurator struct {
	Log *base.LogObject
}

// Create writes resolv.conf.
func (c *ResolvConfConfigurator) Create(ctx context.Context, item depgraph.Item) error {
	return c.generateResolvConf(item)
}

// Modify writes updated resolv.conf.
func (c *ResolvConfConfigurator) Modify(ctx context.Context, oldItem, newItem depgraph.Item) (err error) {
	return c.generateResolvConf(newItem)
}

func (c *ResolvConfConfigurator) generateResolvConf(item depgraph.Item) error {
	config, isResolvConf := item.(ResolvConf)
	if !isResolvConf {
		err := fmt.Errorf("invalid item type: %T (expected ResolvConf)", item)
		c.Log.Error(err)
		return err
	}
	destfile, err := os.Create(resolvConfFilename)
	if err != nil {
		err = fmt.Errorf("failed to create resolv.conf: %w", err)
		c.Log.Error(err)
		return err
	}
	defer destfile.Close()
	if _, err = destfile.WriteString("# Generated by nim\n"); err != nil {
		c.Log.Error(err)
		return err
	}
	if _, err = destfile.WriteString("# Do not edit\n"); err != nil {
		c.Log.Error(err)
		return err
	}
	var written []net.IP
	for ifName, dnsServers := range config.DNSServers {
		c.Log.Functionf("generateResolvConf: %s has %d servers: %v",
			ifName, len(dnsServers), dnsServers)
		_, err = destfile.WriteString(fmt.Sprintf("# From %s\n", ifName))
		if err != nil {
			c.Log.Error(err)
			return err
		}
		// Avoid duplicate IP addresses for nameservers.
		for _, server := range dnsServers {
			duplicate := false
			for _, a := range written {
				if a.Equal(server) {
					duplicate = true
				}
			}
			if duplicate {
				_, err = destfile.WriteString(
					fmt.Sprintf("# nameserver %s\n", server))
				if err != nil {
					c.Log.Error(err)
					return err
				}
			} else {
				_, err = destfile.WriteString(
					fmt.Sprintf("nameserver %s\n", server))
				if err != nil {
					c.Log.Error(err)
					return err
				}
				written = append(written, server)
			}
		}
	}
	if _, err = destfile.WriteString("options rotate\n"); err != nil {
		c.Log.Error(err)
		return err
	}
	if _, err = destfile.WriteString("options attempts:5\n"); err != nil {
		c.Log.Error(err)
		return err
	}
	if err = destfile.Sync(); err != nil {
		c.Log.Error(err)
		return err
	}
	return nil
}

// Delete always returns error. NIM never reverts back to the original content of resolv.conf.
func (c *ResolvConfConfigurator) Delete(ctx context.Context, item depgraph.Item) error {
	return errors.New("not implemented")
}

// NeedsRecreate returns false - Modify is able to apply any change.
func (c *ResolvConfConfigurator) NeedsRecreate(oldItem, newItem depgraph.Item) (recreate bool) {
	return false
}
